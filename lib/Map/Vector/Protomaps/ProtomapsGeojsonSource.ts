import Point from "@mapbox/point-geometry";
import geojsonvt from "geojson-vt";
import { makeObservable, observable, runInAction } from "mobx";
import {
  Bbox,
  GeomType,
  Feature as ProtomapsFeature,
  TileSource,
  Zxy
} from "protomaps-leaflet";
import {
  FeatureCollectionWithCrs,
  toFeatureCollection
} from "../../../ModelMixins/GeojsonMixin";
import {
  PROTOMAPS_DEFAULT_TILE_SIZE,
  PROTOMAPS_TILE_BUFFER
} from "../../ImageryProvider/ProtomapsImageryProvider";

type GeojsonVtFeature = {
  id: any;
  type: GeomType;
  geometry: [number, number][][] | [number, number][];
  tags: any;
};

type GeojsonVtTile = {
  features: GeojsonVtFeature[];
  numPoints: number;
  numSimplified: number;
  numFeatures: number;
  source: any;
  x: number;
  y: number;
  z: number;
  transformed: boolean;
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
};

/** Extent (of coordinates) of tiles generated by geojson-vt */
export const geojsonvtExtent = 4096;

/** Layer name to use with geojson-vt
 *  This must be used in PaintRules/LabelRules (eg `dataLayer: "layer"`)
 */
export const GEOJSON_SOURCE_LAYER_NAME = "layer";

export class ProtomapsGeojsonSource implements TileSource {
  /** Data object from Options */
  private readonly data: string | FeatureCollectionWithCrs;

  /** Resolved geojsonObject (if applicable) */
  @observable.ref
  geojsonObject: FeatureCollectionWithCrs | undefined;

  /** Geojson-vt tileIndex (if applicable) */
  tileIndex: Promise<any> | undefined;

  constructor(url: string | FeatureCollectionWithCrs) {
    makeObservable(this);
    this.data = url;
    if (!(typeof url === "string")) {
      this.geojsonObject = url;
    }
  }

  /** Fetch geoJSON data (if required) and tile with geojson-vt */
  private async fetchData() {
    let result: FeatureCollectionWithCrs | undefined;
    if (typeof this.data === "string") {
      result = toFeatureCollection(await (await fetch(this.data)).json());
    } else {
      result = this.data;
    }

    runInAction(() => (this.geojsonObject = result));

    return geojsonvt(result, {
      buffer:
        (PROTOMAPS_TILE_BUFFER / PROTOMAPS_DEFAULT_TILE_SIZE) * geojsonvtExtent,
      extent: geojsonvtExtent,
      maxZoom: 24
    });
  }

  public async get(
    c: Zxy,
    tileSize: number
  ): Promise<Map<string, ProtomapsFeature[]>> {
    if (!this.tileIndex) {
      this.tileIndex = this.fetchData();
    }

    // request a particular tile
    const tile = (await this.tileIndex).getTile(c.z, c.x, c.y) as GeojsonVtTile;
    const result = new Map<string, ProtomapsFeature[]>();

    if (tile && tile.features && tile.features.length > 0) {
      result.set(
        GEOJSON_SOURCE_LAYER_NAME,
        geojsonVtTileToProtomapsFeatures(tile.features, tileSize)
      );
    }

    return result;
  }
}

export const geomTypeMap = (
  type: string | null | undefined
): GeomType | null => {
  switch (type) {
    case "Point":
      return GeomType.Point;
    case "LineString":
      return GeomType.Line;
    case "Polygon":
      return GeomType.Polygon;
    case "MultiPoint":
      return GeomType.Point;
    case "MultiLineString":
      return GeomType.Line;
    case "MultiPolygon":
      return GeomType.Line;
    default:
      return null;
  }
};

export function geojsonVtTileToProtomapsFeatures(
  geojsonVtFeatures: GeojsonVtFeature[],
  tileSize: number
): ProtomapsFeature[] {
  const scale = tileSize / geojsonvtExtent;

  const protomapsFeatures: ProtomapsFeature[] = [];

  for (const f of geojsonVtFeatures) {
    const transformedGeom: Point[][] = [];
    let numVertices = 0;

    // Calculate bbox
    const bbox: Bbox = {
      minX: Infinity,
      minY: Infinity,
      maxX: -Infinity,
      maxY: -Infinity
    };
    // Multi geometry (eg polygon, multi-line string)
    if (Array.isArray(f.geometry[0][0])) {
      const geom = f.geometry as [number, number][][];

      for (const g1 of geom) {
        const transformedG1: Point[] = [];
        for (const g2 of g1) {
          const transformedG2 = [g2[0] * scale, g2[1] * scale];
          if (bbox.minX > transformedG2[0]) {
            bbox.minX = transformedG2[0];
          }

          if (bbox.maxX < transformedG2[0]) {
            bbox.maxX = transformedG2[0];
          }

          if (bbox.minY > transformedG2[1]) {
            bbox.minY = transformedG2[1];
          }

          if (bbox.maxY < transformedG2[1]) {
            bbox.maxY = transformedG2[1];
          }
          transformedG1.push(new Point(transformedG2[0], transformedG2[1]));
          numVertices++;
        }

        transformedGeom.push(transformedG1);
      }
    }
    // Flat geometry (line string, point)
    else {
      const geom = f.geometry as [number, number][];
      const transformedGeom: Point[] = [];

      for (const g1 of geom) {
        const transformedG1 = [g1[0] * scale, g1[1] * scale];

        if (bbox.minX > transformedG1[0]) {
          bbox.minX = transformedG1[0];
        }

        if (bbox.maxX < transformedG1[0]) {
          bbox.maxX = transformedG1[0];
        }

        if (bbox.minY > transformedG1[1]) {
          bbox.minY = transformedG1[1];
        }

        if (bbox.maxY < transformedG1[1]) {
          bbox.maxY = transformedG1[1];
        }
        transformedGeom.push(new Point(transformedG1[0], transformedG1[1]));
      }
      numVertices = transformedGeom.length;
    }

    protomapsFeatures.push({
      props: f.tags,
      bbox,
      geomType: f.type,
      geom: transformedGeom,
      numVertices
    });
  }

  return protomapsFeatures;
}
